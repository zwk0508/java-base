# 数字的进制

数字可以表示为不同进制的格式，二进制、八进制、十进制和十六进制的数据。

### 二进制

二进制是由0和1组成的数字，逢2进1

### 八进制

八进制是由0到7组成的数字，逢8进1

### 十进制

十进制是由0到9组成的数字，逢10进1

### 十六进制

十六进制是由0到9和a-f组成的数字，逢16进1

### 示例

| 十进制 | 二进制   | 八进制 | 十六进制 |
|-----|-------|-----|------|
| 1   | 1     | 1   | 1    |
| 2   | 10    | 2   | 2    |
| 3   | 11    | 3   | 3    |
| 4   | 100   | 4   | 4    |
| 5   | 101   | 5   | 5    |
| 6   | 110   | 6   | 6    |
| 7   | 111   | 7   | 7    |
| 8   | 1000  | 10  | 8    |
| 9   | 1001  | 11  | 9    |
| 10  | 1010  | 12  | a    |
| 11  | 1011  | 13  | b    |
| 12  | 1100  | 14  | c    |
| 13  | 1101  | 15  | d    |
| 14  | 1110  | 16  | e    |
| 15  | 1111  | 17  | f    |
| 16  | 10000 | 20  | 10   |

### 进制转换

###### 十进制转二进制

连续除以2并记录余数,直到商为0为止,将所有记录下来的余数倒序排列，得到的就是原十进制数对应的二进制数。

例如 13 转为二进制

- 13 / 2 = 6 ... 1
- 6 / 2 = 3 ... 0
- 3 / 2 = 1 ... 1
- 1 / 2 = 0 ... 1

最终转为二进制数就是： 1101

###### 二进制转十进制

每个二进制位上的数值乘以相应的2的位数减一次幂，并将结果相加的方式来计算

例如 1101 转为十进制

`1 * 2^(4-1) + 1 * 2^(3-1) + 0 * 2^(2-1) + 1 * 2^(1-1) = 8 + 4 + 0 + 1 = 13`

###### 十进制转八进制 十进制转十六进制

同理 十进制转二进制

例如 127 转八进制

- 127 / 8 = 15 ... 7
- 15 / 8 = 1 ... 7
- 1 / 8 = 0 ... 1

转为八进制就是 177

127 转十六进制

- 127 / 16 = 7 ... 15
- 7 / 16 = 0 ... 7

由于 15 对应的是f 所以转为十六进制就是 7f

###### 八进制转十进制 十六进制转十进制

同理 二进制转十进制

例如 八进制 177 转十进制

`1 * 8 ^(3-1) + 7 * 8 ^ (2-1) + 7 * 8^(1-1) = 64 + 56 +7 = 127`

十六进制 7f 转十进制

`7 * 16^(2-1) + 15*16^(1-1) = 7*16+15 = 112 + 15 = 127`

###### 二进制转八进制

采用分组的方式，每三位一组转换成对应的八进制数，最后将所有得到的八进制数连接起来即可

例如 110111 转为八进制数

分为两组 110 111

- 110 -> 6
- 111 -> 7
- 转为八进制就是 67

###### 二进制转十六进制

采用分组的方式，每四位一组转换成对应的十六进制数，最后将所有得到的十六进制数连接起来即可

例如 1101110 转为八进制数

分为两组 110 1110

- 110 -> 6
- 1111 -> 15 -> f
- 转为十六进制就是 6f

###### 八进制转二进制

将每个八进制位转换为其等价的三位二进制数

例如 67 转为二进制

- 6 -> 110
- 7 -> 111
- 转为二进制就是 110111

###### 十六进制转二进制

将每个十六进制位转换为其等价的四位二进制数

例如 6f 转为二进制

- 6 -> 110
- f -> 15 -> 1111
- 转为二进制就是 1101111

### 原码、补码和反码

补码和反码是计算机中用于表示负数的一种方法，整数的最高一位表示符号 0 正数 1 负数

- 原码：
    - 原码是最直观的表示方法，符号位用来标识正负，0代表正数，1代表负数，其余位表示数值的绝对值。

- 反码：

    - 对于正数，其反码与原码相同。
    - 对于负数，反码则是原码去掉符号位后，其余各位按位取反（0变1，1变0）。
    - 反码在一定程度上解决了负数的表示问题，但并不能直接用于加减法运算，因为在某些情况下可能出现多余的“-0”问题。
  
- 补码：

    - 对于正数，补码也与原码相同。
    - 对于负数，补码是在反码的基础上，最低位（也就是最右边的位）再加1。
    - 补码不仅解决了反码中存在的“-0”问题，而且通过补码形式，所有的加减法运算都可以统一使用加法器来完成，大大简化了计算机硬件设计。

